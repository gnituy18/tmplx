<!-- prettier-ignore -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Docs | tmplx</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-normalize@3.0.1/modern-normalize.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/tokyo-night-dark.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <nav>
      <h2>tmplx Docs</h2>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#installing">Installing</a></li>
        <li><a href="#pages-and-routing">Pages and Routing</a></li>
        <li><a href="#tmplx-script">tmplx Script</a></li>
        <li>
          <a href="#expression-interpolation">Expression Interpolation</a>
        </li>
        <li><a href="#state">State</a></li>
        <li><a href="#derived-state">Derived State</a></li>
        <li><a href="#event-handler">Event Handler</a></li>
        <li><a href="#init">init()</a></li>
        <li>
          <h3>Dev Tools</h3>
          <ul>
            <li><a href="#syntax-highlight">Syntax Highlight</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <main>
      <h2 id="introduction">Introduction</h2>
      <p>
        tmplx is a framework for building full-stack web applications using only
        Go and HTML. Its goal is to make building web apps simple, intuitive,
        and fun again. It significantly reduces cognitive load by:
      </p>
      <ol>
        <li>keeping frontend and backend logic close together</li>
        <li>providing reactive UI updates driven by Go variables</li>
        <li>requiring zero new syntax</li>
      </ol>
      <p>
        Developing with tmplx feels like writing a more intuitive version of Go
        templates where the UI magically becomes reactive.
      </p>
      <div
        style="
          padding: 2rem;
          display: flex;
          justify-content: center;
          align-items: center;
          border: solid SlateGray;
          border-radius: 0.25rem;
        "
      >
        <div>
          <tx-todo></tx-todo>
        </div>
      </div>
      <pre>
        <code tx-ignore class="language-html">&lt;script type=&quot;text/tmplx&quot;&gt;
  var list []string
  var item string = &quot;&quot;
  
  func add() {
    list = append(list, item)
    item = &quot;&quot;
  }
  
  func remove(i int) {
    list = append(list[0:i], list[i+1:]...)
  }
&lt;/script&gt;

&lt;label&gt;&lt;input type=&quot;text&quot; tx-value=&quot;item&quot;&gt;&lt;/label&gt;
&lt;button tx-onclick=&quot;add()&quot;&gt;Add&lt;/button&gt;
&lt;ol&gt;
  &lt;li 
    tx-for=&quot;i, l := range list&quot;
    tx-key=&quot;l&quot;
    tx-onclick=&quot;remove(i)&quot;&gt;
    { l }
  &lt;/li&gt;
&lt;/ol&gt;</code></pre>

      <p>
        You start by creating an HTML file. It can be a page or a reusable
        component, depending on where you place it. tmplx respects the HTML
        standard. There's no new syntax for
      </p>
      <p>
        You use the <code tx-ignore>&lt;script type="text/tmplx"&gt;</code> tag
        to embed valid Go code and make the page or component dynamic. tmplx
        uses a subset of Go syntax to provide reactive features like local
        state, derived values, and event handlers. At the same time, because the
        script is valid Go, you can implement any backend logic—such as database
        queries—directly in the template.
      </p>
      <p>
        tmplx compiles the HTML templates and embedded Go code into Go functions
        that render the HTML on the server and generate HTTP handlers for
        interactive events. On each interaction, the current state is sent to
        the server, which computes updates and returns both new HTML and the
        updated state. The result is server-rendered pages with lightweight
        client-side swapping (similar to <a href="https://htmx.org/">htmx</a>).
        The interactivity plumbing is handled automatically by the tmplx
        compiler and runtime—you just implement the features.
      </p>
      <p>
        Most modern web applications separate the frontend and backend into
        different languages and teams. tmplx eliminates this split by letting
        you build the entire interactive application in a single language—Go.
        With this approach, the mental effort needed to track how data flows
        from the source to the UI is reduced to a minimum. The fewer
        transformations you perform on your data, the fewer bugs you introduce.
      </p>
      <h2 id="installing">Installing</h2>

      <p>tmplx requires Go 1.22 or later.</p>
      <pre><code tx-ignore>$ go install github.com/gnituy18/tmplx@latest</code></pre>
      <p>
        This adds tmplx to your Go bin directory (usually $GOPATH/bin or
        $HOME/go/bin). Make sure that directory is in your PATH.
      </p>
      <p>After installation, verify it works:</p>
      <pre><code tx-ignore>$ tmplx --help</code></pre>

      <h2 id="pages-and-routing">Pages and Routing</h2>
      <p>
        A <strong>page</strong> is a standalone HTML file that has its own URL
        in your web app.
      </p>
      <p>All pages are placed in the <strong>pages</strong> directory.</p>
      <p>
        tmplx uses <strong>filesystem-based routing</strong>. The route for a
        page is the relative path of the HTML file inside the
        <strong>pages</strong> directory, without the
        <code>.html</code> extension. For example:
      </p>
      <ul>
        <li><code>pages/index.html</code> → <code>/</code></li>
        <li><code>pages/about.html</code> → <code>/about</code></li>
        <li>
          <code>pages/admin/dashboard.html</code> →
          <code>/admin/dashboard</code>
        </li>
      </ul>

      <p>
        When the file is named <code>index.html</code>, the
        <code>index</code> part is omitted from the route (it serves the
        directory path). To get a route like <code>/index</code>, place
        <code>index.html</code> in a subdirectory named <code>index</code>.
      </p>
      <ul>
        <li><code>pages/index/index.html</code> → <code>/index</code></li>
      </ul>
      <p>
        Multiple file paths can map to the same route. Choose the style you
        prefer. Duplicate routes cause compilation failure.
      </p>

      <ul>
        <li><code>pages/login/index.html</code> → <code>/login</code></li>
        <li><code>pages/login.html</code> → <code>/login</code></li>
      </ul>

      <p>
        To add URL parameters (path wildcards), use curly braces {} in directory
        or file names inside the pages directory. The name inside {} must be a
        valid Go identifier.
      </p>
      <ul>
        <li>
          <code tx-ignore>pages/user/{user_id}.html</code> →
          <code tx-ignore>/user/{user_id}</code>
        </li>
        <li>
          <code tx-ignore>pages/blog/{year}/{slug}.html</code> →
          <code tx-ignore>/blog/{year}/{slug}</code>
        </li>
      </ul>
      <p>
        These patterns are compatible with Go's
        <code tx-ignore>net/http.ServeMux</code> (Go 1.22+). The parameter
        values are available in page initialisation through tmplx comments.
      </p>
      <p>
        tmplx compiles all pages into a single Go file you can import into your
        Go project. The pages directory can be outside your project, but keeping
        it inside is recommended.
      </p>

      <p>
        Default pages location: <code>./pages</code>. Change it with the
        <code>-pages</code> flag:
      </p>
      <pre><code tx-ignore>$ tmplx -pages="/some/other/location"</code></pre>

      <h2 id="tmplx-script">tmplx Script</h2>
      <p>
        <code>&lt;script type="text/tmplx"&gt;</code> is a special tag that you
        can add to your page or component to declare <a href="#state">state</a>,
        <a href="#derived-state">derived state</a>,
        <a href="#event-handlers">event handlers</a>, and the special
        <a href="#init">init()</a> function to control your UI or add backend
        logic.
      </p>
      <p>
        Each page or component file can have exactly <strong>one</strong> tmplx
        script. Multiple scripts cause a compilation error.
      </p>
      <p>
        In pages, place it anywhere inside <code>&lt;head&gt;</code> or
        <code>&lt;body&gt;</code>.
      </p>
      <pre><code tx-ignore>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    ...
    &lt;script type="text/tmplx"&gt;
      // Go code here
    &lt;/script&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code>
      </pre>
      <p>In components, place it at the root level.</p>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  // Go code here
&lt;/script&gt;
...
...</code></pre>

      <h2 id="expression-interpolation">Expression Interpolation</h2>
      <p>
        Use curly braces <code tx-ignore>{}</code> to insert
        <a href="https://go.dev/ref/spec#Expressions">Go expressions</a> into
        HTML. Expressions are allowed only in:
      </p>
      <ul>
        <li><strong>text nodes</strong></li>
        <li><strong>attribute values</strong></li>
      </ul>
      <p>Placing expressions anywhere else causes a parsing error.</p>

      <p tx-ignore>
        tmplx converts expression results to strings using
        <code><a href="https://pkg.go.dev/fmt#Sprint">fmt.Sprint</a></code
        >. The difference is that in <strong>text nodes</strong> the output is
        <strong>HTML-escaped</strong> to prevent cross-site scripting (XSS)
        attacks.
      </p>

      <p>
        Expressions run on the server every time the page loads or a component
        re-renders after an event. Avoid side effects in expressions, such as
        database queries or heavy computations, because they execute on every
        render.
      </p>

      <pre><code tx-ignore class="language-html">&lt;p class='{ strings.Join([]string{"c1", "c2"}, " ") }'&gt;
 Hello, { user.GetNameById(0) }!
&lt;/p&gt;</code>
      </pre>

      <pre><code tx-ignore class="language-html">&lt;p class="c1 c2"&gt;
 Hello, tmplx!
&lt;/p&gt;</code></pre>

      <p tx-ignore>
        Add the <code>tx-ignore</code> attribute to an element to disable
        expression interpolation in that element's attributes and its direct
        text children. Descendant elements are still processed normally.
      </p>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { "ignored" }
  &lt;span&gt;{ "not" + " ignored" }&lt;/span&gt;
&lt;/p&gt;</code>
      </pre>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { "ignored" }
  &lt;span&gt;not ignored&lt;/span&gt;
&lt;/p&gt;</code></pre>

      <h2>Syntax Highlight</h2>
      <a href="https://github.com/gnituy18/tmplx.nvim">Neovim Plugin</a>
    </main>
  </body>
</html>
