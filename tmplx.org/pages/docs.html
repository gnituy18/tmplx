<!-- prettier-ignore -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Docs | Tmplx</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-normalize@3.0.1/modern-normalize.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/tokyo-night-dark.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <nav>
      <h2>Tmplx Docs</h2>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#installing">Installing</a></li>
        <li><a href="#pages-and-routing">Pages and Routing</a></li>
        <li><a href="#tmplx-script">Tmplx Script</a></li>
        <li>
          <a href="#expression-interpolation">Expression Interpolation</a>
        </li>
        <li><a href="#state">State</a></li>
        <li><a href="#derived-state">Derived State</a></li>
        <li><a href="#event-handler">Event Handler</a></li>
        <li><a href="#init">init()</a></li>
        <li>
          <h3>Dev Tools</h3>
          <ul>
            <li><a href="#syntax-highlight">Syntax Highlight</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <main>
      <h2 id="introduction">Introduction</h2>
      <p>
        Tmplx is a framework for building full-stack web applications using only
        Go and HTML. Its goal is to make building web apps simple, intuitive,
        and fun again. It significantly reduces cognitive load by:
      </p>
      <ol>
        <li>keeping frontend and backend logic close together</li>
        <li>providing reactive UI updates driven by Go variables</li>
        <li>requiring zero new syntax</li>
      </ol>
      <p>
        Developing with Tmplx feels like writing a more intuitive version of Go
        templates where the UI magically becomes reactive.
      </p>
      <div
        style="
          padding: 2rem;
          display: flex;
          justify-content: center;
          align-items: center;
          border: solid SlateGray;
          border-radius: 0.25rem;
        "
      >
        <div>
          <tx-todo></tx-todo>
        </div>
      </div>
      <pre>
        <code tx-ignore class="language-html">&lt;script type=&quot;text/tmplx&quot;&gt;
  var list []string
  var item string = &quot;&quot;
  
  func add() {
    list = append(list, item)
    item = &quot;&quot;
  }
  
  func remove(i int) {
    list = append(list[0:i], list[i+1:]...)
  }
&lt;/script&gt;

&lt;label&gt;&lt;input type=&quot;text&quot; tx-value=&quot;item&quot;&gt;&lt;/label&gt;
&lt;button tx-onclick=&quot;add()&quot;&gt;Add&lt;/button&gt;
&lt;ol&gt;
  &lt;li 
    tx-for=&quot;i, l := range list&quot;
    tx-key=&quot;l&quot;
    tx-onclick=&quot;remove(i)&quot;&gt;
    { l }
  &lt;/li&gt;
&lt;/ol&gt;</code></pre>

      <p>
        You start by creating an HTML file. It can be a page or a reusable
        component, depending on where you place it. Tmplx respects the HTML
        standard, which you are already familiar with, so you can take any
        existing HTML file and it will still work.
      </p>
      <p>
        You use the <code tx-ignore>&lt;script type="text/tmplx"&gt;</code> tag
        to embed valid Go code and make the page or component dynamic. Tmplx
        uses a subset of Go syntax to provide reactive features like local
        state, derived values, and event handlers. At the same time, because the
        script is valid Go, you can implement any backend logic—such as database
        queries—directly in the template.
      </p>
      <p>
        Tmplx compiles the HTML templates and embedded Go code into Go functions
        that render the HTML on the server and generate HTTP handlers for
        interactive events. On each interaction, the current state is sent to
        the server, which computes updates and returns both new HTML and the
        updated state. The result is server-rendered pages with lightweight
        client-side swapping (similar to <a href="https://htmx.org/">htmx</a>). The interactivity plumbing is
        handled automatically by the Tmplx compiler and runtime—you just
        implement the features.
      </p>
      <p>
        Most modern web applications separate the frontend and backend into
        different languages and teams. Tmplx eliminates this split by letting
        you build the entire interactive application in a single language—Go.
        With this approach, the mental effort needed to track how data flows
        from the source to the UI is reduced to a minimum. The fewer
        transformations you perform on your data, the fewer bugs you introduce.
      </p>

      <h2 id="installing">Installing</h2>
      <pre><code tx-ignore>$ go install github.com/gnituy18/tmplx@latest</code></pre>
      <h2 id="pages-and-routing">Pages and Routing</h2>
      <p>
        You put all your html files into the pages directory that it can either
        be in your project or outside of your project.
      </p>
      <p>
        Tmplx uses <strong>filesystem-based routing</strong>. The route is the
        relative path of the HTML file inside the
        <strong>pages</strong> directory without the
        <code>.html</code> extension.
      </p>
      <p>
        If the file is named <code>index.html</code>, omit
        <code>index</code> (it serves the directory path). For a route like
        <code>/index</code>, place <code>index.html</code> in a directory named
        <code>index</code>.
      </p>
      <pre><code tx-ignore>pages/index.html → /
pages/about.html → /about
pages/index/index.html → /index
pages/admin/dashboard.html → /admin/dashboard</code>
      </pre>
      <p>
        There can be multiple file paths that map to the same route. Choose one
        style that fits your preference. Duplicate routes will cause compilation
        failure.
      </p>
      <pre><code tx-ignore>pages/login.html → /login
pages/login/index.html → /login</code>
      </pre>

      <p>
        <a href="https://pkg.go.dev/net/http#hdr-Patterns-ServeMux"
          >Wildcards</a
        >
        are supported out of the box using <code tx-ignore>{}</code> in
        directory or file names. Captured values can be used in initial states
        via tmplx comments. Wildcard names must be valid Go identifiers.
      </p>
      <pre><code tx-ignore>pages/user/{user_id}.html → /user/{user_id}</code>
      </pre>
      <p>
        Tmplx compiles all pages into a single Go file you can import into your
        Go project, so the pages directory can be outside your project, but
        keeping it inside is recommended.
      </p>

      <p>
        Default pages location: <code>./pages</code>. Change it with the
        <code>-pages</code> flag:
      </p>
      <pre><code tx-ignore>$ tmplx -pages="/some/other/location"</code></pre>

      <h2 id="tmplx-script">Tmplx Script</h2>
      <p>
        Tmplx lets you embed Go code directly in your HTML using a special
        <code>&lt;script&gt;</code> tag with <code>type="text/tmplx"</code>.
        Inside the tag, you write normal Go code to declare
        <a href="#state">state</a>, <a href="#derived-state">derived state</a>,
        <a href="#event-handler">event handlers</a>, and the special
        <a href="#init">init()</a> function.
      </p>
      <p>
        Each page or component HTML file may contain
        <strong>exactly one</strong> tmplx script. For pages, you can place it
        anywhere inside <code>&lt;head&gt;</code> or <code>&lt;body&gt;</code>.
        For components, place the tmplx script at the root of the file. Having
        multiple tmplx scripts will cause a compilation error.
      </p>
      <pre><code tx-ignore>&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My Page&lt;/title&gt;

    &lt;script type="text/tmplx"&gt;
      ...
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <h2 id="expression-interpolation">Expression Interpolation</h2>
      <p>
        Embed Go expressions in HTML using {} for dynamic content. You can only
        place Go expressions in text nodes or attribute values; other placements
        cause parsing errors. text nodes output is HTML-escaped; attribute it is
        not escaped.
      </p>

      <p>
        Every expression is run once when the page is load or every component is
        rerender, so bemindful with every code you put in the interpolation like
        accessing database or run heavying loading functions.
      </p>
      <pre><code tx-ignore class="language-html">&lt;p class='{ strings.Join([]string{&quot;c1&quot;, &quot;c2&quot;}, &quot; &quot;) }'&gt;
 Hello, { user.GetNameById(&quot;id&quot;) }!
&lt;/p&gt;</code></pre>
      <pre>
        <code>&lt;p class=&quot;c1 c2&quot;&gt;
 Hello, tmplx!
&lt;/p&gt;</code>
      </pre>

      <p>
        You can add tx-ignore to disable Go expression interpolation for that
        specific node's attribute values and its text children, but not the
        element children.
      </p>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { &quot;ignored&quot; }
  &lt;span&gt; { &quot;not&quot; + &quot;ignore&quot; } &lt;/span&gt;
&lt;/p&gt;</code>
      </pre>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { &quot;ignored&quot; }
  &lt;span&gt; not ignored &lt;/span&gt;
&lt;/p&gt;</code></pre>

      <h2>Syntax Highlight</h2>
      <a href="https://github.com/gnituy18/tmplx.nvim">Neovim Plugin</a>
    </main>
  </body>
</html>
