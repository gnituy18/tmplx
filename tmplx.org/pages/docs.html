<!-- prettier-ignore -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Docs | tmplx</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-normalize@3.0.1/modern-normalize.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/tokyo-night-dark.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <nav>
      <h2>tmplx Docs</h2>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#installing">Installing</a></li>
        <li><a href="#pages-and-routing">Pages and Routing</a></li>
        <li><a href="#tmplx-script">tmplx Script</a></li>
        <li>
          <a href="#expression-interpolation">Expression Interpolation</a>
        </li>
        <li><a href="#state">State</a></li>
        <li><a href="#derived">Derived</a></li>
        <li><a href="#event-handler">Event Handler</a></li>
        <li><a href="#init">init()</a></li>
        <li><a href="#path-parameter">Path Parameter</a></li>
        <li>
          <a href="#control-flow">Control Flow</a>
          <ul>
            <li><a href="#conditionals">Conditionals</a></li>
            <li><a href="#loops">Loops</a></li>
          </ul>
        </li>
        <li><a href="#input-binding">üöß Input Binding</a></li>
        <li><a href="#template">&lt;template&gt;</a></li>
        <li>
          <a href="#component">Component</a>
          <ul>
            <li><a href="#props">Props</a></li>
            <li><a href="#slot">&lt;slot&gt;</a></li>
          </ul>
        </li>
        <li>
          Dev Tools
          <ul>
            <li><a href="#syntax-highlight">Syntax Highlight</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <main>
      <h2 id="introduction">Introduction</h2>
      <p>
        tmplx is a framework for building full-stack web applications using only
        Go and HTML. Its goal is to make building web apps simple, intuitive,
        and fun again. It significantly reduces cognitive load by:
      </p>
      <ol>
        <li>
          <strong>keeping frontend and backend logic close together</strong>
        </li>
        <li>
          <strong>providing reactive UI updates driven by Go variables</strong>
        </li>
        <li><strong>requiring zero new syntax</strong></li>
      </ol>
      <p>
        Developing with tmplx feels like writing a more intuitive version of Go
        templates where the UI magically becomes reactive.
      </p>
      <tx-example-wrapper>
        <tx-todo></tx-todo>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore class="language-html">&lt;script type=&quot;text/tmplx&quot;&gt;
  var list []string
  var item string = &quot;&quot;
  
  func add() {
    list = append(list, item)
    item = &quot;&quot;
  }
  
  func remove(i int) {
    list = append(list[0:i], list[i+1:]...)
  }
&lt;/script&gt;

&lt;label&gt;&lt;input type=&quot;text&quot; tx-value=&quot;item&quot;&gt;&lt;/label&gt;
&lt;button tx-onclick=&quot;add()&quot;&gt;Add&lt;/button&gt;
&lt;ol&gt;
  &lt;li 
    tx-for=&quot;i, l := range list&quot;
    tx-key=&quot;l&quot;
    tx-onclick=&quot;remove(i)&quot;&gt;
    { l }
  &lt;/li&gt;
&lt;/ol&gt;</code></pre>

      <p>
        You start by creating an HTML file. It can be a page or a reusable
        component, depending on where you place it.
      </p>
      <p>
        You use the <code tx-ignore>&lt;script type="text/tmplx"&gt;</code> tag
        to embed Go code and make the page or component dynamic. tmplx uses a
        subset of Go syntax to provide reactive features like
        <a href="#state">state</a>, <a href="derived">derived</a>, and
        <a href="event-lhandler">event handlers</a>. At the same time, because
        the script is valid Go, you can implement any backend logic‚Äîsuch as
        database queries‚Äîdirectly in the template.
      </p>
      <p>
        tmplx compiles the HTML templates and embedded Go code into Go functions
        that render the HTML on the server and generate HTTP handlers for
        interactive events. On each interaction, the current state is sent to
        the server, which computes updates and returns both new HTML and the
        updated state. The result is server-rendered pages with lightweight
        client-side swapping (similar to <a href="https://htmx.org/">htmx</a>).
        The interactivity plumbing is handled automatically by the tmplx
        compiler and runtime‚Äîyou just implement the features.
      </p>
      <p>
        Most modern web applications separate the frontend and backend into
        different languages and teams. tmplx eliminates this split by letting
        you build the entire interactive application in a single language‚ÄîGo.
        With this approach, the mental effort needed to track how data flows
        from the source to the UI is reduced to a minimum. The fewer
        transformations you perform on your data, the fewer bugs you introduce.
      </p>
      <h2 id="installing">Installing</h2>

      <p>tmplx requires Go 1.22 or later.</p>
      <pre><code tx-ignore>$ go install github.com/gnituy18/tmplx@latest</code></pre>
      <p>
        This adds tmplx to your Go bin directory (usually $GOPATH/bin or
        $HOME/go/bin). Make sure that directory is in your PATH.
      </p>
      <p>After installation, verify it works:</p>
      <pre><code tx-ignore>$ tmplx --help</code></pre>

      <h2 id="pages-and-routing">Pages and Routing</h2>
      <p>
        A <strong>page</strong> is a standalone HTML file that has its own URL
        in your web app.
      </p>
      <p>All pages are placed in the <strong>pages</strong> directory.</p>
      <p>
        tmplx uses <strong>filesystem-based routing</strong>. The route for a
        page is the relative path of the HTML file inside the
        <strong>pages</strong> directory, without the
        <code>.html</code> extension. For example:
      </p>
      <ul>
        <li><code>pages/index.html</code> ‚Üí <code>/</code></li>
        <li><code>pages/about.html</code> ‚Üí <code>/about</code></li>
        <li>
          <code>pages/admin/dashboard.html</code> ‚Üí
          <code>/admin/dashboard</code>
        </li>
      </ul>

      <p>
        When the file is named <code>index.html</code>, the
        <code>index</code> part is omitted from the route (it serves the
        directory path). To get a route like <code>/index</code>, place
        <code>index.html</code> in a subdirectory named <code>index</code>.
      </p>
      <ul>
        <li><code>pages/index/index.html</code> ‚Üí <code>/index</code></li>
      </ul>
      <p>
        Multiple file paths can map to the same route. Choose the style you
        prefer. Duplicate routes cause compilation failure.
      </p>

      <ul>
        <li><code>pages/login/index.html</code> ‚Üí <code>/login</code></li>
        <li><code>pages/login.html</code> ‚Üí <code>/login</code></li>
      </ul>

      <p>
        To add URL parameters (path wildcards), use curly braces {} in directory
        or file names inside the pages directory. The name inside {} must be a
        valid Go identifier.
      </p>
      <ul>
        <li>
          <code tx-ignore>pages/user/{user_id}.html</code> ‚Üí
          <code tx-ignore>/user/{user_id}</code>
        </li>
        <li>
          <code tx-ignore>pages/blog/{year}/{slug}.html</code> ‚Üí
          <code tx-ignore>/blog/{year}/{slug}</code>
        </li>
      </ul>
      <p>
        These patterns are compatible with Go's
        <code tx-ignore>net/http.ServeMux</code> (Go 1.22+). The parameter
        values are available in page initialisation through tmplx comments.
      </p>
      <p>
        tmplx compiles all pages into a single Go file you can import into your
        Go project. The pages directory can be outside your project, but keeping
        it inside is recommended.
      </p>

      <p>
        Default pages location: <code>./pages</code>. Change it with the
        <code>-pages</code> flag:
      </p>
      <pre><code tx-ignore>$ tmplx -pages="/some/other/location"</code></pre>

      <h2 id="tmplx-script">tmplx Script</h2>
      <p>
        <code>&lt;script type="text/tmplx"&gt;</code> is a special tag that you
        can add to your page or component to declare <a href="#state">state</a>,
        <a href="#derived">derived</a>,
        <a href="#event-handler">event handler</a>, and the special
        <a href="#init">init()</a> function to control your UI or add backend
        logic.
      </p>
      <p>
        Each page or component file can have exactly <strong>one</strong> tmplx
        script. Multiple scripts cause a compilation error.
      </p>
      <p>
        In pages, place it anywhere inside <code>&lt;head&gt;</code> or
        <code>&lt;body&gt;</code>.
      </p>
      <pre><code tx-ignore>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    ...
    &lt;script type="text/tmplx"&gt;
      // Go code here
    &lt;/script&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code>
      </pre>
      <p>In components, place it at the root level.</p>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  // Go code here
&lt;/script&gt;
...
...</code></pre>

      <h2 id="expression-interpolation">Expression Interpolation</h2>
      <p>
        Use curly braces <code tx-ignore>{}</code> to insert
        <a href="https://go.dev/ref/spec#Expressions">Go expressions</a> into
        HTML. Expressions are allowed only in:
      </p>
      <ul>
        <li><strong>text nodes</strong></li>
        <li><strong>attribute values</strong></li>
      </ul>
      <p>Placing expressions anywhere else causes a parsing error.</p>

      <p tx-ignore>
        tmplx converts expression results to strings using
        <code><a href="https://pkg.go.dev/fmt#Sprint">fmt.Sprint</a></code
        >. The difference is that in <strong>text nodes</strong> the output is
        <strong>HTML-escaped</strong> to prevent cross-site scripting (XSS)
        attacks.
      </p>

      <p>
        Expressions run on the server every time the page loads or a component
        re-renders after an event. Avoid side effects in expressions, such as
        database queries or heavy computations, because they execute on every
        render.
      </p>

      <pre><code tx-ignore class="language-html">&lt;p class='{ strings.Join([]string{"c1", "c2"}, " ") }'&gt;
 Hello, { user.GetNameById(0) }!
&lt;/p&gt;</code>
      </pre>

      <pre><code tx-ignore class="language-html">&lt;p class="c1 c2"&gt;
 Hello, tmplx!
&lt;/p&gt;</code></pre>

      <p tx-ignore>
        Add the <code>tx-ignore</code> attribute to an element to disable
        expression interpolation in that element's attributes and its direct
        text children. Descendant elements are still processed normally.
      </p>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { "ignored" }
  &lt;span&gt;{ "not" + " ignored" }&lt;/span&gt;
&lt;/p&gt;</code>
      </pre>

      <pre><code tx-ignore class="language-html">&lt;p tx-ignore&gt;
  { "ignored" }
  &lt;span&gt;not ignored&lt;/span&gt;
&lt;/p&gt;</code></pre>

      <h2 id="state">State</h2>
      <p>
        <strong>State</strong> is the mutable data that describes a component's
        current condition.
      </p>

      <p>
        Declaring state works like declaring variables in Go's package scope. If
        you provide no initial value, the state starts with the zero value for
        its type.
      </p>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
var name string
&lt;/script&gt;</code></pre>

      <p>To set an initial value, use the <code>=</code> operator.</p>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
var name string = "tmplx"
&lt;/script&gt;</code></pre>

      <p>Although the syntax follows valid Go code, these rules apply:</p>
      <ol>
        <li><strong>Only one identifier per declaration.</strong></li>
        <li>
          <strong
            >The type must be explicitly declared and JSON-compatible.</strong
          >
        </li>
      </ol>
      <p>
        The 1st rule is enforced by the compiler. The 2nd is not checked at
        compile time (for now) and will cause a runtime error if violated.
      </p>

      <h3>Some invalid state declarations:</h3>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
// ‚ùå Must explicitly declare the type
var str = ""

// ‚ùå Cannot use the := short declaration
num := 1

// ‚ùå Type must be JSON-marshalable/unmarshalable
var f func(int) = func(i int) { ... }
var w io.Writer

// ‚ùå Only one identifier per declaration
var a, b int = 10, 20
var a, b int = f()
&lt;/script&gt;</code></pre>

      <h3>Some valid state declarations:</h3>
      <pre><code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
// ‚úÖ Zero value
var id int64

// ‚úÖ With initial value
var address string = "..."

// ‚úÖ Initialized with a function call (assuming the package is imported)
var username string = user.GetNameById("id")

// ‚úÖ Complex JSON-compatible types
var m map[string]int = map[string]int{"key": 100}
&lt;/script&gt;</code></pre>

      <h2 id="derived">Derived</h2>
      A <strong>derived</strong> is a <strong>read-only</strong> value that is
      automatically calculated from states. It updates whenever those states
      change.

      <p>
        Declaring a derived works the same way as declaring package-level
        variables in Go. When the right-hand side of the declaration
        <strong>references existing state or other derived values</strong>, it
        is treated as a derived value.
      </p>

      <p>
        Derived values follow most of the same rules as regular state variables,
        but with some differences:
      </p>

      <ol>
        <li><strong>Only one identifier per declaration.</strong></li>
        <li><strong>The type must be specified explicitly.</strong></li>
        <li>
          <strong
            >Derived values cannot be modified directly in event handlers,
            though they may be read.</strong
          >
        </li>
      </ol>

      <pre>
        <code tx-ignore>&lt;script type="text/tmplx"&gt;
  var num1 int = 100 // state
  var num2 int = num1 * 2 // derived
&lt;/script&gt;

...
&lt;p&gt;{num1} * 2 = {num2}&lt;/p&gt;</code></pre>

      <pre>
        <code tx-ignore>&lt;script type="text/tmplx"&gt;
  var classStrs []string = []string{"c1", "c2", "c3"} // state
  var class string = strings.Join(classStrs, " ") // derived
&lt;/script&gt;

...
&lt;p class="{class}"&gt; ... &lt;/p&gt;</code></pre>

      <h2 id="event-handler">Event Handler</h2>
      <p>
        Event handlers let you respond to frontend events with backend logic or
        update state to trigger UI changes.
      </p>
      <p>
        To declare an event handler, define a Go function in the global scope of
        the <code>&lt;script type="text/tmplx"&gt;</code> block. Bind it to a
        DOM event by adding an attribute that starts with
        <code>tx-on</code> followed by the event name (e.g.,
        <code>tx-onclick</code>).
      </p>
      <pre><code tx-ignore>&lt;script type="text/tmplx"&gt;
  var counter int = 0

  func add1() {
    counter += 1
  }
&lt;/script&gt;

&lt;p&gt;{ counter }&lt;/p&gt;
&lt;button tx-onclick="add1()"&gt;Add 1&lt;/button&gt;</code></pre>

      <p>
        In this example, the <code>add1</code> handler runs every time the
        button is clicked. The <code>counter</code> state increases by 1, and
        the paragraph updates automatically.
      </p>
      <p>
        It‚Äôs not magic. tmplx compiles each event handler into an HTTP endpoint.
        The runtime JavaScript attaches a lightweight listener that sends the
        required state to the endpoint, receives the updated HTML fragment,
        merges the new state, and swaps the affected part of the DOM. It feels
        like direct backend access from the client, but it‚Äôs just a simple API
        call with targeted DOM swapping.
      </p>

      <h3>Arguments</h3>
      You can add arguments from local variable declared within
      <code>tx-if</code>, or <code>tx-for</code> with the following rules:
      <ul>
        <li>
          <strong
            >Argument names cannot match state or derived state names.
          </strong>
        </li>
        <li><strong>Argument types must be JSON-compatible.</strong></li>
      </ul>

      <tx-example-wrapper>
        <tx-addn></tx-addn>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  var counter int = 0

  func addNum(num int) {
    counter += num
  }
&lt;/script&gt;

&lt;p&gt;{ counter }&lt;/p&gt;
&lt;button tx-for=&quot;i := 0; i &lt; 10; i++&quot; tx-key=&quot;i&quot; tx-onclick=&quot;addNum(i)&quot;&gt;
  +{ i }
&lt;/button&gt;</code></pre>

      <h3>Inline Statements</h3>

      <p>
        For simple actions, embed Go statements directly in
        <code>tx-on*</code> attributes to update state. This avoids defining
        separate handler functions.
      </p>
      <tx-example-wrapper>
        <tx-double></tx-double>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  var val int = 1
&lt;/script&gt;

&lt;p&gt;{ val }&lt;/p&gt;
&lt;button tx-onclick=&quot;val *= 2&quot;&gt;double it!&lt;/button&gt;</code>
      </pre>
      <h2 id="init">init()</h2>
      <p>
        <code>init()</code> is a special function that runs automatically
        <strong>once</strong> when a <strong>page</strong> is first rendered.
        Components cannot use this function.
      </p>
      <tx-example-wrapper>
        <tx-current-time></tx-current-time>
      </tx-example-wrapper>

      <pre>
        <code tx-ignore>&lt;script type="text/tmplx"&gt;
  var t string

  func init() {
    t = fmt.Sprint(time.Now().Format(time.RFC3339))
  }
&lt;/script&gt;

&lt;p&gt;{ t }&lt;/p&gt;</code></pre>

      <p>
        Another common use case is to initialize one state from another state
        without turning the second variable into a derived state.
      </p>
      <pre><code tx-ignore>&lt;script type="text/tmplx"&gt;
  var a int = 1
  var b int

  func init() {
    b = a * 2 // b remains a regular state
  }
&lt;/script&gt;</code></pre>

      <h2 id="path-parameter">Path Parameters</h2>
      <p>
        You can inject path parameters into states using a
        <code>//tx:path</code> comment placed directly above the state
        declaration. This feature works only in
        <a href="#pages-and-routing">pages</a> and requires the state to be of
        type <code>string</code>.
      </p>

      <p>
        For example, given a route pattern like
        <code tx-ignore>/blog/post/{post_id}</code>, you can access the
        <code>post_id</code> parameter as follows:
      </p>

      <pre><code tx-ignore>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script type=&quot;text/tmplx&quot;&gt;
      // tx:path post_id
      var postId string

      var post Post
      
      func init() {
        post = db.GetPost(postId)
      }
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;{ post.Title }&lt;/h1&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>
        The value of the <code>post_id</code> path parameter is automatically
        injected into the <code>postId</code> state during initialization. After
        that, <code>postId</code> behaves like any other state and can be read
        or modified as needed.
      </p>

      <h2 id="control-flow">Control Flow</h2>
      <p>
        tmplx avoids new custom syntax for conditionals and loops because that
        would increase compiler complexity. Instead, it embeds control flow
        directly into HTML attributes, similar to Vue.js and
        <a href="https://alpinejs.dev/">Alpine.js</a>.
      </p>

      <h3 id="conditionals">Conditionals</h3>
      <p>
        To conditionally render elements, use the <code>tx-if</code>,
        <code>tx-else-if</code>, and <code>tx-else</code> attributes on the
        desired tags. The values for <code>tx-if</code> and
        <code>tx-else-if</code> can be any valid Go expression that would fit in
        an <code>if</code> or <code>else if</code> statement. The
        <code>tx-else</code> attribute needs no value.
      </p>

      <tx-example-wrapper>
        <tx-cond></tx-cond>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  var num int
&lt;/script&gt;

&lt;button tx-onclick=&quot;num++&quot;&gt;change&lt;/button&gt;
&lt;div&gt;
  &lt;p tx-if=&quot;num % 3 == 0&quot; style=&quot;background: red; color: white&quot;&gt;red&lt;/p&gt;
  &lt;p tx-else-if=&quot;num % 3 == 1&quot; style=&quot;background: blue; color: white&quot;&gt;blue&lt;/p&gt;
  &lt;p tx-else style=&quot;background: green; color: white&quot;&gt;green&lt;/p&gt;
&lt;/div&gt;</code>
      </pre>

      <p>
        You can declare <strong>local variables</strong> and handle errors
        exactly as you would in regular Go code. Local variables declared in
        conditionals are available to the element and its descendants, just like
        in Go.
      </p>
      <pre><code tx-ignore>&lt;p tx-if=&quot;user, err := user.GetUser(); err != nil&quot;&gt;
  &lt;span tx-if=&quot;err == ErrNotFound&quot;&gt;User not found&lt;/span&gt;
&lt;/p&gt;
&lt;p tx-else-if='user.Name == &quot;&quot;'&gt;user.Name not set&lt;/p&gt;
&lt;p tx-else&gt;Hi, { user.Name }&lt;/p&gt;</code></pre>

      <p>
        A conditional group consists of
        <strong>consecutive sibling nodes</strong> that share the same parent.
        Disconnected nodes are not treated as part of the same group. A
        standalone <code>tx-else-if</code> or <code>tx-else</code> without a
        preceding <code>tx-if</code> will cause a compilation error.
      </p>

      <h3 id="loops">Loops</h3>
      <p>
        To repeat elements, use the <code>tx-for</code> attribute. Its value can
        be any valid Go <code>for</code> statement, including
        <strong>classic for</strong> or <strong>range for</strong>.
      </p>

      <p>
        Local variables declared in the loop are available to the element and
        all of its descendants, just like in Go.
      </p>

      <p>
        Always add a <code>tx-key</code> attribute with a unique value for each
        item. This gives the compiler a unique identifier for the node during
        updates.
      </p>

      <tx-example-wrapper>
        <tx-triangle></tx-triangle>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  var counter int = 5
&lt;/script&gt;

&lt;div&gt;
  &lt;span&gt; { counter } &lt;/span&gt;
  &lt;button tx-onclick=&quot;counter++&quot;&gt;+&lt;/button&gt;
&lt;/div&gt;
&lt;div tx-for=&quot;h := 0; h &lt; counter; h++&quot; tx-key=&quot;h&quot;&gt;
  &lt;span tx-for=&quot;s := 0; s &lt; counter-h-1; s++&quot; tx-key=&quot;s&quot;&gt;_&lt;/span&gt;
  &lt;span tx-for=&quot;i := 0; i &lt; h*2+1; i++&quot; tx-key=&quot;i&quot;&gt;*&lt;/span&gt;
&lt;/div&gt;</code>
      </pre>

      <pre><code tx-ignore>&lt;div tx-for=&quot;_, user := range users&quot;&gt;
  { user.Id }: { user.Name }
&lt;/div&gt;</code></pre>

      <h2 id="input-binding">üöß Input Binding</h2>
      <p>
        <strong
          >This feature is in active development and may change or be removed in
          the future.</strong
        >
      </p>
      <p>
        tmplx provides two-way binding (kind of) for
        <code>&lt;input&gt;</code> elements using the
        <code>tx-value</code> attribute. The input value is kept in sync with a
        state variable on the client side.
      </p>
      <p>
        As the user types, the client-side state updates immediately. The
        displayed value only refreshes after a server round-trip that causes a
        re-render. Conversely, when another event handler modifies the state,
        the input value updates automatically on the next render.
      </p>

      <tx-example-wrapper>
        <tx-greeting></tx-greeting>
      </tx-example-wrapper>
      <pre>
        <code tx-ignore>&lt;script type=&quot;text/tmplx&quot;&gt;
  var name string = &quot;&quot;

  func update() {}
&lt;/script&gt;

&lt;input type=&quot;text&quot; tx-value=&quot;name&quot; placeholder=&quot;Enter your name&quot; /&gt;
&lt;button tx-onclick=&quot;update()&quot;&gt;Greet&lt;/button&gt;

&lt;p tx-if='name != &quot;&quot;'&gt;Hello, { name }&lt;/p&gt;</code></pre>

      <p>
        Typing updates the client state instantly, but the greeting only changes
        after clicking the button, which triggers a server round-trip and
        re-render.
      </p>

      <p>
        This is a current limitation of server-side re-renders. For smooth live
        preview, combine tmplx with a client-side library like
        <a href="https://alpinejs.dev/">Alpine.js</a> (or similar) to handle
        instant updates locally.
      </p>

      <h2 id="template">&lt;template&gt;</h2>
      <p>docs in progress...</p>
      <h2 id="component">Component</h2>
      <p>docs in progress...</p>

      <h2 id="syntax-highlight">Syntax Highlight</h2>
      <a href="https://github.com/gnituy18/tmplx.nvim">Neovim Plugin</a>
    </main>
  </body>
</html>
<!-- ### Control Flow


#### `tx-for`
You can put every thing that fit Go's `for` statement.
```html
...
<div tx-for="_, user := range users">
  { user.Id }: { user.Name }
</div>
```
```html
...
<div tx-for="i := 0; i < 10; i++">
  <div tx-for="j := 0; j < 10; j++">
    { i } * { j } = { i * j }
  </div>
</div>
```
 -->
